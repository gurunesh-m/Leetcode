# 1365. How Many Numbers Are Smaller Than the Current Number

This problem asks a simple question: for every number in the array, how many other numbers are strictly smaller than it? The trick is choosing the right approach for your situation.

## Understanding the Problem

You're given an array `nums`. For each `nums[i]`, count how many values in the array are **strictly smaller** than it.

Example:

```
nums = [8, 1, 2, 2, 3]
output = [4, 0, 1, 1, 3]
```

The important idea: your answer for each position depends on how many elements in the whole list are smaller—not greater, not smaller-or-equal. **Strictly smaller.**

---

## Approach 1: Brute Force (O(n²))

This is the most direct solution. Compare every element with every other element.

### Behavior

Fix an index `i`. Loop through all indices `j`. Count how many values `nums[j] < nums[i]`.

### Code

```python
class Solution(object):
    def smallerNumbersThanCurrent(self, nums):
        ans = []
        for i in range(len(nums)):
            count = 0
            for j in range(len(nums)):
                if i != j and nums[j] < nums[i]:
                    count += 1
            ans.append(count)
        return ans
```

### When to use

When you're learning, testing logic, or dealing with very small inputs. This is easy to write but doesn't scale.

---

## Approach 2: Sorting + Mapping (O(n log n))

This is the elegant and scalable solution.

### Key Insight

If you sort the numbers, the **index** of the first occurrence of a number tells you exactly how many numbers are smaller than it.

Example:

```
nums = [8,1,2,2,3]
sorted_nums = [1,2,2,3,8]
```

First indices:

* 1 → 0
* 2 → 1
* 3 → 3
* 8 → 4

Thus each number in the original array maps to the number of smaller ones.

### Code

```python
class Solution(object):
    def smallerNumbersThanCurrent(self, nums):
        sorted_nums = sorted(nums)
        first_index = {}

        for i, val in enumerate(sorted_nums):
            if val not in first_index:
                first_index[val] = i

        return [first_index[n] for n in nums]
```

### Why It Works

Sorting places values in increasing order. The first index of a value in a sorted list is exactly the count of numbers smaller than it.

### When to use

This is the recommended general-purpose solution. Clean. Fast. Reliable.

---

## Approach 3: Frequency Counting (O(n) if range is small)

This works because the constraints say values are between 0 and 100.

### Idea

1. Count how often each number appears.
2. Build prefix sums to know how many numbers are smaller than any given number.

### Code

```python
class Solution(object):
    def smallerNumbersThanCurrent(self, nums):
        freq = [0] * 101
        for n in nums:
            freq[n] += 1

        # prefix sum: freq[i] becomes count of numbers < i
        for i in range(1, 101):
            freq[i] += freq[i - 1]

        result = []
        for n in nums:
            smaller = freq[n - 1] if n > 0 else 0
            result.append(smaller)

        return result
```

### When to use

Best when input range is small. Extremely fast.

---

## Choosing an Approach

* Prefer **sorting + mapping** for clarity and performance.
* Use **frequency counting** when the value range is small.
* Use **brute force** only when learning or constraints allow.

---

## Final Reminder

Don’t think in steps. Think in behaviors.

This problem becomes simple the moment you stop thinking about loops and start thinking about what *"smaller numbers"* means in relation to sorting and ordering.

This insight scales across many DSA problems.
