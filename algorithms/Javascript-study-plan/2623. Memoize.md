# 2623. Memoize Memoization in JavaScript

## What is Memoization?

Memoization is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again. It's a form of caching that can dramatically improve performance for functions with repeated calculations.

### Key Characteristics

- **Trade-off**: Trades memory for speed
- **Best for**: Pure functions (same input always produces same output)
- **Use cases**: Recursive algorithms, expensive computations, API calls

## How Memoization Works

```
First call with args (x, y):
1. Check cache → Not found
2. Compute result
3. Store in cache
4. Return result

Second call with args (x, y):
1. Check cache → Found!
2. Return cached result (skip computation)
```

## Basic Implementation

```javascript
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
}
```

### Why Use `Map` instead of Object?

- Better performance for frequent additions/deletions
- Keys can be any type (not just strings)
- Easier to check key existence with `.has()`
- Maintains insertion order

## LeetCode Problem: 2623. Memoize

**Difficulty**: Medium

### Problem Statement

Given a function `fn`, return a memoized version of that function.

A memoized function is a function that will never be called twice with the same inputs. Instead it will return a cached value.

You can assume there are 3 possible input functions:
- `sum(a, b)` - returns `a + b`
- `fib(n)` - returns `1` if `n <= 1` or `fib(n - 1) + fib(n - 2)`
- `factorial(n)` - returns `1` if `n <= 1` or `factorial(n - 1) * n`

**Important**: For `sum`, arguments `(a, b)` and `(b, a)` should be treated as different calls.

### Solution

```javascript
/**
 * @param {Function} fn
 * @return {Function}
 */
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        // Create unique key from arguments
        const key = JSON.stringify(args);
        
        // Return cached result if exists
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        // Compute and cache result
        const result = fn(...args);
        cache.set(key, result);
        
        return result;
    };
}
```

### Example Usage

```javascript
// Example 1: Sum
const sum = (a, b) => a + b;
const memoizedSum = memoize(sum);

memoizedSum(2, 3); // Computes: 5
memoizedSum(2, 3); // Cached: 5
memoizedSum(3, 2); // Computes: 5 (different arg order)

// Example 2: Fibonacci
const fib = (n) => n <= 1 ? 1 : fib(n - 1) + fib(n - 2);
const memoizedFib = memoize(fib);

memoizedFib(10); // Much faster with memoization!
```

### Why JSON.stringify for the Key?

```javascript
JSON.stringify([2, 3])  // "[2,3]"
JSON.stringify([3, 2])  // "[3,2]"
JSON.stringify([5])     // "[5]"
```

This ensures:
- Different argument orders create different keys
- Multiple arguments are handled correctly
- Simple and reliable key generation

## Performance Analysis

### Without Memoization - Fibonacci(40)

```
fib(40) calls fib(39) and fib(38)
fib(39) calls fib(38) and fib(37)
fib(38) is calculated TWICE already!
...
Total function calls: 331,160,281
```

### With Memoization - Fibonacci(40)

```
fib(40) → fib(39) → fib(38) → ... → fib(1)
Each value calculated ONCE
Total function calls: 40
```

**Time Complexity**:
- First call: O(fn complexity)
- Cached calls: O(1)

**Space Complexity**: O(n) where n = unique argument combinations

## Common Pitfalls

### ❌ Don't Memoize Impure Functions

```javascript
// BAD - function depends on external state
let counter = 0;
const impure = (x) => x + counter++;
const memoized = memoize(impure);

memoized(5); // 5
counter = 10;
memoized(5); // Still returns 5 (cached), but should be 15
```

### ❌ Watch Out for Object Arguments

```javascript
const fn = (obj) => obj.value * 2;
const memoized = memoize(fn);

memoized({value: 5}); // Computes: 10
memoized({value: 5}); // Computes again: 10 (different object reference!)
```

### ✅ Use Memoization For

- Recursive functions (fibonacci, factorial)
- Expensive pure computations
- Functions called repeatedly with same inputs
- Data transformations

## Advanced: LRU Cache Memoization

For long-running applications, limit cache size:

```javascript
function memoize(fn, maxSize = 100) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            const value = cache.get(key);
            // Move to end (most recently used)
            cache.delete(key);
            cache.set(key, value);
            return value;
        }
        
        // Remove oldest if at capacity
        if (cache.size >= maxSize) {
            const firstKey = cache.keys().next().value;
            cache.delete(firstKey);
        }
        
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
}
```

## Real-World Applications

1. **React**: `useMemo` and `useCallback` hooks
2. **Redux**: Reselect library for memoized selectors
3. **GraphQL**: DataLoader for batching and caching
4. **API Calls**: Cache responses to avoid redundant requests
5. **Dynamic Programming**: Optimize recursive algorithms

## Summary

Memoization is a powerful optimization technique that:
- Caches function results based on inputs
- Dramatically improves performance for repeated calculations
- Works best with pure functions
- Requires careful consideration of memory usage

The LeetCode problem demonstrates the fundamentals: create a cache, generate unique keys from arguments, and return cached results when available.
