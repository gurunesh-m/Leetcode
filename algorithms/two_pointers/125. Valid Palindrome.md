# 125. Valid Palindrome

A **palindrome** is a string that reads the same forward and backward *after* cleaning it.
For this problem, cleaning means:

* Converting uppercase letters to lowercase
* Removing all non-alphanumeric characters

Your goal is to check if the cleaned version behaves like a mirror.

---

## Problem Statement

Given a string `s`, return `true` if it becomes a palindrome after:

1. Lowercasing all characters
2. Removing all characters that are **not** letters or digits

If the resulting string is empty, it is still a palindrome.

### Examples

**Input:**
`"A man, a plan, a canal: Panama"`
**Output:** `true`
**Reason:** becomes `"amanaplanacanalpanama"`

**Input:**
`"race a car"`
**Output:** `false`

**Input:**
`" "`
**Output:** `true`
**Reason:** becomes empty string
Empty string is a valid palindrome.

---

## Approach: Two Pointers + Skipping Garbage

Rather than creating a new filtered string, we use two pointers:

* `i` starts at the left
* `j` starts at the right

Both move inward.
Whenever either side hits a non-alphanumeric character, we skip it.
Once both sides land on valid characters, we compare them.

If they ever mismatch → not a palindrome.

If the pointers cross without mismatches → palindrome.

This gives us:

* **Time:** O(n)
* **Space:** O(1)

Efficient, clean, and avoids extra memory allocation.

---

## Built-in Functions Used

### `str.lower()`

Converts all characters in the string to lowercase.
This ensures case doesn’t matter (`"A"` and `"a"` become the same).

### `str.isalnum()`

Returns `True` only if the character is a letter (A–Z, a–z) or digit (0–9).
Everything else — spaces, punctuation, symbols — gets ignored during comparison.

These two helpers remove a ton of manual checking work.

---

## Code

```python
class Solution(object):
    def isPalindrome(self, s):
        s = s.lower()
        i = 0
        j = len(s) - 1

        while i < j:
            while i < j and not s[i].isalnum():
                i += 1
            while i < j and not s[j].isalnum():
                j -= 1

            if s[i] != s[j]:
                return False

            i += 1
            j -= 1

        return True
```

---

This problem looks simple, but it teaches discipline:
work with the original data, avoid unnecessary operations, and let the pointer logic carry the load.
