# 88. Merge Sorted Array

**Difficulty:** Easy
**Topic:** Two Pointers, Arrays

---

## Problem Statement

You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n` representing the number of valid elements in `nums1` and `nums2`.

* `nums1` has a length of `m + n`.
* The first `m` elements of `nums1` are valid; the last `n` elements are placeholders (`0`).
* `nums2` has exactly `n` elements.

Merge `nums2` into `nums1` so that `nums1` becomes a single sorted array in non-decreasing order.

> The result must be stored **in-place** in `nums1`.

---

## Example

**Input**

```
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3
```

**Output**

```
[1,2,2,3,5,6]
```

---

## Approach 1: Optimal In-Place Merge (Two Pointers from the End)

### Idea

Instead of merging from the front (which would overwrite values in `nums1`), we merge **from the back**.

* Pointer `i` starts at the last valid element of `nums1`
* Pointer `j` starts at the last element of `nums2`
* Pointer `k` starts at the very end of `nums1`

At each step, place the larger of `nums1[i]` and `nums2[j]` at position `k`.

### Why this works

* The largest elements belong at the end
* Empty space already exists at the end of `nums1`
* No extra memory is required

### Code (Java)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (j >= 0) {
            if (i >= 0 && nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
    }
}
```

### Complexity

* **Time:** O(m + n)
* **Space:** O(1)

This is the **preferred solution** for interviews.

---

## Approach 2: Merge Using Extra Array

### Idea

Create a temporary array and merge both arrays just like the merge step in merge sort.

### Steps

1. Use two pointers to compare elements of `nums1` and `nums2`
2. Store the smaller element in a new array
3. Copy remaining elements if one array finishes early
4. Copy the merged result back into `nums1`

### Code (Java)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] arr = new int[m + n];
        int n1 = 0;
        int n2 = 0;
        int a = 0;

        while (n1 < m && n2 < n) {
            if (nums1[n1] > nums2[n2]) {
                arr[a] = nums2[n2];
                n2++;
            } else {
                arr[a] = nums1[n1];
                n1++;
            }
            a++;
        }

        while (n1 < m) {
            arr[a++] = nums1[n1++];
        }

        while (n2 < n) {
            arr[a++] = nums2[n2++];
        }

        for (int i = 0; i < arr.length; i++) {
            nums1[i] = arr[i];
        }
    }
}
```

### Complexity

* **Time:** O(m + n)
* **Space:** O(m + n)

---

## Comparison

| Approach             | Time   | Space  | Notes                         |
| -------------------- | ------ | ------ | ----------------------------- |
| In-place (Backwards) | O(m+n) | O(1)   | Optimal, interview-friendly   |
| Extra Array          | O(m+n) | O(m+n) | Easier to reason, not optimal |

---

## Key Takeaway

When an array has extra space at the end, think **backwards**.
Most beginners miss this and jump straight to extra memory.

This problem is less about syntax and more about **pointer discipline and thinking before overwriting data**.
