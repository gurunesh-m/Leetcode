# 3075. Maximize Happiness of Selected Children

**Difficulty:** Medium
**Topics:** Greedy, Sorting
**Link:**

* Problem: [https://leetcode.com/problems/maximize-happiness-of-selected-children/](https://leetcode.com/problems/maximize-happiness-of-selected-children/)
* Reference solution: [https://leetcode.com/problems/maximize-happiness-of-selected-children/solutions/7436813/sorting-greedy-python-c-by-srinivasa_pra-4nlj](https://leetcode.com/problems/maximize-happiness-of-selected-children/solutions/7436813/sorting-greedy-python-c-by-srinivasa_pra-4nlj)

---

## Problem Summary

You are given:

* An integer array `happiness` of length `n`
* A positive integer `k`

You must select **k children** over **k turns**.

### Rules:

* When you select a child, **all unselected children lose 1 happiness**
* Happiness **never goes below 0**
* You want to **maximize the sum** of happiness values of the selected children

---

## Key Insight (Greedy Logic)

Each time you pick a child, future picks are worth **less** because happiness decreases.

So the optimal strategy is obvious:

1. **Sort happiness in descending order**
2. Pick the largest happiness first
3. On the `i-th` pick, effective happiness becomes

   ```
   max(happiness[i] - i, 0)
   ```
4. Stop after `k` picks

Why this works:

* Every turn penalizes remaining children equally
* Picking high values early avoids losing potential happiness later

If this doesn’t click instantly, that’s a red flag — you’re missing the greedy intuition.

---

## Algorithm

1. Sort `happiness` in descending order
2. Initialize `sum = 0`
3. For `i` from `0` to `k-1`:

   * Add `max(happiness[i] - i, 0)` to `sum`
4. Return `sum`

---

## Time & Space Complexity

* **Time:** `O(n log n)` (sorting)
* **Space:** `O(1)` extra (ignoring sort internals)

---

## JavaScript Solution

```javascript
/**
 * @param {number[]} happiness
 * @param {number} k
 * @return {number}
 */
var maximumHappinessSum = function(happiness, k) {
    happiness.sort((a, b) => b - a);

    let sum = 0;
    for (let i = 0; i < k; i++) {
        sum += Math.max(happiness[i] - i, 0);
    }
    return sum;
};
```

---

## Python 3 Solution

```python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happiness.sort(reverse=True)

        total = 0
        for i in range(k):
            total += max(happiness[i] - i, 0)
        return total
```

---

## Java Solution

```java
import java.util.*;

class Solution {
    public long maximumHappinessSum(int[] happiness, int k) {
        Arrays.sort(happiness);

        long sum = 0;
        int n = happiness.length;

        for (int i = 0; i < k; i++) {
            int value = happiness[n - 1 - i] - i;
            sum += Math.max(value, 0);
        }
        return sum;
    }
}
```

---

## Common Mistakes (Read This)

* Simulating decrements every turn → wasteful and slow
* Using a priority queue → unnecessary
* Forgetting `max(…, 0)` → wrong answers
* Overengineering → classic LeetCode trap

This is a **sorting + greedy** problem, not a data-structure flex.

---

## Final Thought

This problem tests whether you can:

* Spot monotonic decay
* Apply greedy ordering
* Avoid simulation like a brute-force addict

If this felt hard, slow down and think **effect before action** — applies to code and life.
