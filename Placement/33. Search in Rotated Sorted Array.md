# LeetCode 33: Search in Rotated Sorted Array

---

## ðŸ”— Problem Links

* **LeetCode Number:** 33
* **Problem Link:** [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

---

## ðŸ’¡ Core Idea and Thinking Process

The fundamental challenge of this problem is that the array is **sorted but rotated**. Usually, sorted arrays scream **Binary Search**, which gives us the required  complexity. However, the rotation breaks the standard ascending property.

### The "One Side is Always Sorted" Rule

The key insight for a rotated sorted array is:

> When you pick any index `mid`, at least one half of the array (either `[low...mid]` or `[mid...high]`) **must be sorted**.

By identifying which side is sorted, we can check if our `target` lies within that range. If it does, we narrow our search to that half. If it doesn't, the target *must* be in the other half.

---

## ðŸ§  Intuition

1. **Standard Binary Search:** We find `mid`.
2. **Identify Sorted Portion:** Compare `nums[low]` with `nums[mid]`.
* If `nums[low] <= nums[mid]`, the **left side** is sorted.
* Otherwise, the **right side** is sorted.


3. **Range Check:** * If the left is sorted: Check if the target is between `nums[low]` and `nums[mid]`.
* If the right is sorted: Check if the target is between `nums[mid]` and `nums[high]`.


4. **Eliminate Half:** Based on the range check, move `low` or `high` to discard the half where the target cannot exist.

---

## ðŸ¢ Brute Force Solution

### Approach

The simplest way is to perform a **Linear Search**. Iterate through the entire array and compare each element with the target.

### Complexity

* **Time Complexity:**  â€” In the worst case, we check every element.
* **Space Complexity:**  â€” No extra space used.

---

## ðŸš€ Optimized Solution (Binary Search)

### Approach

We use two pointers, `low` and `high`, and calculate `mid` in each iteration to divide the search space logarithmically.

### Complexity

* **Time Complexity:**  â€” Each step halves the search space.
* **Space Complexity:**  â€” Only a few variables are used.

### Algorithm Flow Example

**Input:** `nums = [4, 5, 6, 7, 0, 1, 2]`, `target = 0`

1. **Initial state:** `low = 0`, `high = 6`, `mid = 3`.
* `nums[mid]` is `7`. Target `0 != 7`.
* **Check Sorted Half:** `nums[low] (4) <= nums[mid] (7)`. The **Left Side** `[4, 5, 6, 7]` is sorted.
* **Is Target in Range?** Is `0` between `4` and `7`? **No**.
* **Action:** Target must be in the right half. `low = mid + 1` (low = 4).


2. **Second Iteration:** `low = 4`, `high = 6`, `mid = 5`.
* `nums[mid]` is `1`. Target `0 != 1`.
* **Check Sorted Half:** `nums[low] (0) <= nums[mid] (1)`. The **Left Side** `[0, 1]` is sorted.
* **Is Target in Range?** Is `0` between `nums[low] (0)` and `nums[mid] (1)`? **Yes**.
* **Action:** Target is here. `high = mid - 1` (high = 4).


3. **Third Iteration:** `low = 4`, `high = 4`, `mid = 4`.
* `nums[mid]` is `0`. **Target Found!** Return index `4`.



---

## ðŸ’» Implementation

```java
class Solution {
    public int search(int[] nums, int target) {
        int low = 0;
        int n = nums.length;
        int high = n - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            // 1. Found the target
            if (nums[mid] == target) return mid;

            // 2. Identify which half is sorted
            if (nums[low] <= nums[mid]) {
                // Left half is sorted
                if (target >= nums[low] && target < nums[mid]) {
                    // Target is within the sorted left half
                    high = mid - 1;
                } else {
                    // Target is in the right half
                    low = mid + 1;
                }
            } else {
                // Right half is sorted
                if (target > nums[mid] && target <= nums[high]) {
                    // Target is within the sorted right half
                    low = mid + 1;
                } else {
                    // Target is in the left half
                    high = mid - 1;
                }
            }
        }
        // Target not found
        return -1;
    }
}

```
---
