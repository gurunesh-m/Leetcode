# LeetCode 39: Combination Sum

**Problem Link:** [https://leetcode.com/problems/combination-sum/](https://leetcode.com/problems/combination-sum/)

**Difficulty:** Medium

---

## Problem Statement

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

### Constraints:
- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- All elements of `candidates` are **distinct**
- `1 <= target <= 40`

### Examples:

**Example 1:**
```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation: 
2 + 2 + 3 = 7
7 = 7
These are the only two combinations.
```

**Example 2:**
```
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
Explanation:
2 + 2 + 2 + 2 = 8
2 + 3 + 3 = 8
3 + 5 = 8
```

**Example 3:**
```
Input: candidates = [2], target = 1
Output: []
Explanation: No combination sums to 1
```

---

## Core Intuition

Think of this problem like **making change** for a specific amount using unlimited coins of certain denominations. You can use each coin type (candidate) as many times as you want.

### Key Insights:
1. **Unlimited Reuse**: Each number can be used multiple times, so when we pick a number, we can pick it again
2. **Explore All Paths**: We need to explore all possible combinations systematically
3. **Backtracking**: We build combinations incrementally and backtrack when we exceed the target or find a valid solution
4. **Avoid Duplicates**: By always moving forward in the array (or staying at the same index for reuse), we avoid duplicate combinations like [2,3] and [3,2]

---

## Approach 1: Brute Force (Generate All Combinations)

### Idea:
Generate all possible combinations of all lengths and check which ones sum to the target. This is highly inefficient.

### Pseudocode:
```
1. Generate all possible subsets (with repetition allowed)
2. For each subset, calculate the sum
3. If sum equals target, add to result
4. Return result
```

### Why This is Inefficient:
- Generates an enormous number of combinations (exponential)
- Wastes time checking invalid combinations
- For candidates = [2,3,5] and target = 8, it would check [2], [3], [5], [2,2], [2,3], [2,5], [3,3], [3,5], [5,5], [2,2,2], [2,2,3], etc.
- **Time Complexity:** O(n^(target/min)) - extremely large
- **Space Complexity:** O(target/min) for recursion stack

**We won't implement this approach as it's impractical.**

---

## Approach 2: Optimized Solution (Backtracking with Pruning)

### Core Idea:

Use **backtracking** to systematically explore combinations while pruning invalid paths early. Think of it as building a decision tree where:
- Each level decides whether to include the current candidate
- We can reuse the same candidate by staying at the same index
- We prune branches that exceed the target

### Visual Representation:

For `candidates = [2,3,6,7]` and `target = 7`, the recursion tree looks like:

```
                        []
                  /    |    |    \
               [2]   [3]  [6]   [7] ✓
              / | \   |     X
          [2,2][2,3][2,6]X [3,3]
           / |  |  \        |
      [2,2,2][2,2,3]✓   [3,3,3]X
         /     X              X
    [2,2,2,2]X
       X

Legend:
✓ = Valid combination (sum = target)
X = Pruned (sum > target)
```

### Algorithm Flow:

**Step-by-step with Example:** `candidates = [2,3,5]`, `target = 8`

1. **Start:** `backtrack(0, [], 0)`
   - Current: [], Sum: 0, Start index: 0

2. **Add 2:** `backtrack(0, [2], 2)`
   - Current: [2], Sum: 2, Start index: 0
   - Add 2 again: `backtrack(0, [2,2], 4)`
     - Add 2 again: `backtrack(0, [2,2,2], 6)`
       - Add 2 again: `backtrack(0, [2,2,2,2], 8)` ✓ **Found [2,2,2,2]**
       - Backtrack, try 3: sum = 6+3 = 9 > 8, prune
       - Backtrack, try 5: sum = 6+5 = 11 > 8, prune
     - Try 3: `backtrack(1, [2,2,3], 7)`
       - Add 3: sum = 7+3 = 10 > 8, prune
       - Try 5: sum = 7+5 = 12 > 8, prune
     - Try 5: sum = 4+5 = 9 > 8, prune
   - Try 3: `backtrack(1, [2,3], 5)`
     - Add 3: `backtrack(1, [2,3,3], 8)` ✓ **Found [2,3,3]**
     - Try 5: sum = 5+5 = 10 > 8, prune

3. **Try 3:** `backtrack(1, [3], 3)`
   - Add 3: sum = 3+3 = 6
     - Add 3: sum = 6+3 = 9 > 8, prune
     - Try 5: `backtrack(2, [3,5], 8)` ✓ **Found [3,5]**

4. **Try 5:** `backtrack(2, [5], 5)`
   - Add 5: sum = 5+5 = 10 > 8, prune

**Result:** `[[2,2,2,2], [2,3,3], [3,5]]`

### Implementation:

#### Python Solution:

```python
def combinationSum(candidates, target):
    result = []
    
    def backtrack(start, current, current_sum):
        # Base case: found valid combination
        if current_sum == target:
            result.append(current[:])  # Add a copy
            return
        
        # Base case: exceeded target (pruning)
        if current_sum > target:
            return
        
        # Explore candidates from 'start' index onwards
        for i in range(start, len(candidates)):
            # Include candidates[i]
            current.append(candidates[i])
            
            # Recurse with same index 'i' (allow reuse)
            backtrack(i, current, current_sum + candidates[i])
            
            # Backtrack: remove last element
            current.pop()
    
    backtrack(0, [], 0)
    return result
```

#### Java Solution:

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(candidates, target, 0, new ArrayList<>(), 0, result);
        return result;
    }
    
    private void backtrack(int[] candidates, int target, int start, 
                          List<Integer> current, int currentSum, 
                          List<List<Integer>> result) {
        // Base case: found valid combination
        if (currentSum == target) {
            result.add(new ArrayList<>(current));  // Add a copy
            return;
        }
        
        // Base case: exceeded target (pruning)
        if (currentSum > target) {
            return;
        }
        
        // Explore candidates from 'start' index onwards
        for (int i = start; i < candidates.length; i++) {
            // Include candidates[i]
            current.add(candidates[i]);
            
            // Recurse with same index 'i' (allow reuse)
            backtrack(candidates, target, i, current, 
                     currentSum + candidates[i], result);
            
            // Backtrack: remove last element
            current.remove(current.size() - 1);
        }
    }
}
```

### Why This Works:

1. **Recursive Exploration**: We try adding each candidate one by one
2. **Reuse Allowed**: By passing the same index `i` to the recursive call, we allow reusing the same number
3. **Early Pruning**: If `current_sum > target`, we stop exploring that branch
4. **No Duplicates**: By always starting from index `i` (not 0), we ensure combinations like [2,3] and [3,2] aren't both generated

### Optimization: Sorting First

#### Python (Optimized):

```python
def combinationSum(candidates, target):
    result = []
    candidates.sort()  # Sort to enable early termination
    
    def backtrack(start, current, current_sum):
        if current_sum == target:
            result.append(current[:])
            return
        
        for i in range(start, len(candidates)):
            # Early termination: if current number exceeds remaining target
            if current_sum + candidates[i] > target:
                break  # No need to check larger numbers
            
            current.append(candidates[i])
            backtrack(i, current, current_sum + candidates[i])
            current.pop()
    
    backtrack(0, [], 0)
    return result
```

#### Java (Optimized):

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(candidates);  // Sort to enable early termination
        backtrack(candidates, target, 0, new ArrayList<>(), 0, result);
        return result;
    }
    
    private void backtrack(int[] candidates, int target, int start, 
                          List<Integer> current, int currentSum, 
                          List<List<Integer>> result) {
        if (currentSum == target) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        for (int i = start; i < candidates.length; i++) {
            // Early termination: if current number exceeds remaining target
            if (currentSum + candidates[i] > target) {
                break;  // No need to check larger numbers
            }
            
            current.add(candidates[i]);
            backtrack(candidates, target, i, current, 
                     currentSum + candidates[i], result);
            current.remove(current.size() - 1);
        }
    }
}
```

**Why Sorting Helps:**
- Once we encounter a candidate that makes sum exceed target, all subsequent candidates (being larger) will also exceed
- We can `break` instead of `continue`, saving iterations

---

## Complexity Analysis

### Time Complexity: **O(N^(T/M))**
- N = length of candidates
- T = target value
- M = minimum value in candidates
- In the worst case, we might have a recursion tree of depth T/M, and at each level, we can branch N ways
- Practically, pruning significantly reduces this

### Space Complexity: **O(T/M)**
- Recursion stack depth can go up to T/M (when using the smallest candidate repeatedly)
- Result storage not counted as it's the output

---

## Key Takeaways

### The Thinking Process:
1. **Recognize Pattern**: Unlimited reuse + finding all combinations → Backtracking
2. **Decision Tree**: At each step, decide whether to include current candidate
3. **Pruning**: Stop early when sum exceeds target
4. **Avoid Duplicates**: Use index to control exploration order

### Template for Similar Problems:
```python
def backtracking_template(candidates, target):
    result = []
    
    def backtrack(start, current, state):
        # Base case: valid solution
        if is_valid(state):
            result.append(current[:])
            return
        
        # Base case: invalid path (pruning)
        if should_prune(state):
            return
        
        # Explore all choices
        for i in range(start, len(candidates)):
            # Make choice
            current.append(candidates[i])
            
            # Recurse
            backtrack(next_index, current, updated_state)
            
            # Undo choice (backtrack)
            current.pop()
    
    backtrack(0, [], initial_state)
    return result
```

### Common Mistakes to Avoid:
1. ❌ **Python:** Not making a copy when adding to result: `result.append(current)` vs `result.append(current[:])`
   **Java:** Not making a copy: `result.add(current)` vs `result.add(new ArrayList<>(current))`
2. ❌ Starting next recursion from 0 instead of `i` (causes duplicates)
3. ❌ Forgetting to backtrack (pop) after recursive call
   - **Python:** `current.pop()`
   - **Java:** `current.remove(current.size() - 1)`
4. ❌ Not pruning early (checking sum > target)
5. ❌ **Java:** Forgetting to import `java.util.*` (ArrayList, List, Arrays)

---

## Related Problems

- **LeetCode 40:** Combination Sum II (each number used once)
- **LeetCode 216:** Combination Sum III (k numbers that sum to n)
- **LeetCode 377:** Combination Sum IV (count of combinations, order matters)

---

## Visual Aid

![Backtracking Tree Example](https://i.imgur.com/5Q3N5pP.png)

The image above shows how backtracking explores the decision tree, where each node represents a state (current combination and sum), and branches represent choices to include a candidate.

---

## Practice Tips

1. **Draw the recursion tree** for small examples before coding
2. **Trace through** the backtracking calls with pen and paper
3. **Understand when to use** `i` vs `i+1` vs `0` in next recursive call
4. **Master the backtracking template** - it applies to many problems

