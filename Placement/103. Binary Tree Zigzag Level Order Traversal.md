# 103. Binary Tree Zigzag Level Order Traversal

**Difficulty:** Medium  
**Problem Link:** [LeetCode 103 - Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)

---

## Problem Statement

Given the `root` of a binary tree, return the **zigzag level order traversal** of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).

---

## Examples

### Example 1:
```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

**Visual Representation:**
```
      3
     / \
    9  20
      /  \
     15   7
```

### Example 2:
```
Input: root = [1]
Output: [[1]]
```

### Example 3:
```
Input: root = []
Output: []
```

---

## TreeNode Definition

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

---

## Solution Approaches

### Approach 1: BFS (Breadth-First Search) - Brute Force

**Time Complexity:** O(n)  
**Space Complexity:** O(n)

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean leftToRight = true;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> level = new ArrayList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            
            // Reverse the level if needed
            if (!leftToRight) {
                Collections.reverse(level);
            }
            
            result.add(level);
            leftToRight = !leftToRight;
        }
        
        return result;
    }
}
```

**Key Points:**
- Standard BFS level order traversal
- Reverse each alternate level after collection
- Simple but involves reversing arrays which adds O(k) operations per level

---

### Approach 2: BFS (Optimized) - Using Deque

**Time Complexity:** O(n)  
**Space Complexity:** O(n)

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean leftToRight = true;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            LinkedList<Integer> level = new LinkedList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                
                // Add to appropriate end based on direction
                if (leftToRight) {
                    level.addLast(node.val);  // Add to end
                } else {
                    level.addFirst(node.val); // Add to beginning
                }
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            
            result.add(level);
            leftToRight = !leftToRight;
        }
        
        return result;
    }
}
```

**Key Points:**
- Use `LinkedList` for O(1) insertion at both ends
- `addLast()` for left-to-right, `addFirst()` for right-to-left
- No explicit reversal needed
- More efficient than the brute force approach

---

### Approach 3: DFS (Depth-First Search)

**Time Complexity:** O(n)  
**Space Complexity:** O(h) where h is height (recursion stack)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        dfs(root, 0);
        return result;
    }
    
    private void dfs(TreeNode root, int level) {
        if (root == null) return;
        
        // Create new level list if needed
        if (result.size() == level) {
            result.add(new LinkedList<>());
        }
        
        // Add to the appropriate end based on level
        if (level % 2 == 0) {
            // Even level: left to right (add to end)
            result.get(level).add(root.val);
        } else {
            // Odd level: right to left (add to beginning)
            result.get(level).add(0, root.val);
        }
        
        // Recurse left then right
        dfs(root.left, level + 1);
        dfs(root.right, level + 1);
    }
}
```

**Key Points:**
- Pre-order DFS traversal (root → left → right)
- Track level as we go deeper
- Insert at beginning for odd levels, at end for even levels
- Elegant recursive solution
- Space efficient due to no queue needed

---

## Algorithm Flow with Example

Let's trace through **Example 1:** `root = [3,9,20,null,null,15,7]`

```
      3
     / \
    9  20
      /  \
     15   7
```

### BFS Approach - Step-by-Step:

**Initial State:**
```
Queue: [3]
Result: []
Direction: leftToRight = true
```

**Iteration 1 (Level 0):**
```
Level size: 1
Process node 3:
  - Add 3 to level (leftToRight = true, so addLast)
  - Add children: 9, 20 to queue
Level: [3]
Queue: [9, 20]
Result: [[3]]
Toggle: leftToRight = false
```

**Iteration 2 (Level 1):**
```
Level size: 2
Process node 9:
  - Add 9 to level (leftToRight = false, so addFirst)
  - No children
  Level: [9]
Process node 20:
  - Add 20 to level (leftToRight = false, so addFirst)
  - Add children: 15, 7 to queue
  Level: [20, 9]
Queue: [15, 7]
Result: [[3], [20, 9]]
Toggle: leftToRight = true
```

**Iteration 3 (Level 2):**
```
Level size: 2
Process node 15:
  - Add 15 to level (leftToRight = true, so addLast)
  - No children
  Level: [15]
Process node 7:
  - Add 7 to level (leftToRight = true, so addLast)
  - No children
  Level: [15, 7]
Queue: []
Result: [[3], [20, 9], [15, 7]]
```

**Final Output:** `[[3], [20, 9], [15, 7]]`

---

### DFS Approach - Step-by-Step:

**Call Stack Visualization:**

```
dfs(3, 0)
├── level 0 is even → add 3 to end of result[0]
│   Result: [[3]]
├── dfs(9, 1)
│   ├── level 1 is odd → add 9 to beginning of result[1]
│   │   Result: [[3], [9]]
│   ├── dfs(null, 2) → return
│   └── dfs(null, 2) → return
└── dfs(20, 1)
    ├── level 1 is odd → add 20 to beginning of result[1]
    │   Result: [[3], [20, 9]]
    ├── dfs(15, 2)
    │   ├── level 2 is even → add 15 to end of result[2]
    │   │   Result: [[3], [20, 9], [15]]
    │   ├── dfs(null, 3) → return
    │   └── dfs(null, 3) → return
    └── dfs(7, 2)
        ├── level 2 is even → add 7 to end of result[2]
        │   Result: [[3], [20, 9], [15, 7]]
        ├── dfs(null, 3) → return
        └── dfs(null, 3) → return
```

**Final Output:** `[[3], [20, 9], [15, 7]]`

---

## Core Idea & Thinking Process

### Intuition

The problem requires **level order traversal** with an alternating direction pattern. We can achieve this in two ways:

1. **BFS Approach:** Natural for level-order traversal
   - Process nodes level by level using a queue
   - Track direction and insert accordingly
   
2. **DFS Approach:** Less obvious but elegant
   - Traverse depth-first but track the level
   - Insert based on level parity (even/odd)

### Key Insights

**BFS Strategy:**
- Use a queue for standard level order traversal
- Maintain a boolean flag for direction
- Use `LinkedList` with `addFirst()`/`addLast()` for efficient insertion

**DFS Strategy:**
- Pre-order traversal (root → left → right) naturally visits nodes in order
- Track level depth during recursion
- Even levels (0, 2, 4...): add to end (left-to-right)
- Odd levels (1, 3, 5...): add to beginning (right-to-left)

### Why DFS Works?

When we do pre-order DFS and visit left child first:
- At even levels, we want left-to-right: `[9, 20]` → add to end
- At odd levels, we want right-to-left: but we visit left first!
  - Visit 15 first → add to beginning: `[15]`
  - Visit 7 next → add to beginning: `[7, 15]` ❌ Wrong!
  
Wait, this doesn't work! Let me reconsider...

Actually, when we add to the beginning for odd levels:
- Visit 9 → add to beginning: `[9]`
- Visit 20 → add to beginning: `[20, 9]` ✓ Correct!

The key is that we visit left-to-right (9 then 20), but by adding each to the **beginning**, the last visited appears first, giving us the reverse order!

---

## Visual Diagram

![Binary Tree Zigzag Traversal](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

### Zigzag Pattern Visualization:

```
Level 0 (even): →  [3]
                    ↓
Level 1 (odd):  ←  [20, 9]
                    ↓
Level 2 (even): →  [15, 7]
```

---

## Complexity Analysis

### BFS Approach

| Metric | Complexity | Explanation |
|--------|-----------|-------------|
| **Time** | O(n) | Visit each node exactly once |
| **Space** | O(n) | Queue holds at most one level (O(w)), result holds all nodes (O(n)) |

### DFS Approach

| Metric | Complexity | Explanation |
|--------|-----------|-------------|
| **Time** | O(n) | Visit each node exactly once |
| **Space** | O(h) | Recursion stack depth = tree height. Result space is O(n) but not counted |

### Trade-offs

**BFS:**
- ✅ Intuitive for level-order problems
- ✅ Iterative (no stack overflow risk)
- ❌ Requires queue storage

**DFS:**
- ✅ More space-efficient (no queue)
- ✅ Elegant recursive solution
- ❌ Risk of stack overflow for very deep trees
- ❌ Less intuitive for level-order problems

---

## Comparison: BFS vs DFS

| Aspect | BFS | DFS |
|--------|-----|-----|
| **Approach** | Iterative with Queue | Recursive with Level Tracking |
| **Space** | O(w) for queue + O(n) result | O(h) for recursion + O(n) result |
| **Intuition** | Natural for level-order | Clever use of pre-order |
| **Best For** | Wide trees | Deep, narrow trees |
| **Code Length** | Longer | Shorter, more elegant |

---

## Key Takeaways

1. **BFS is natural** for level-order traversal problems
2. **DFS can work** with clever level tracking
3. **LinkedList** provides O(1) insertion at both ends
4. **Level parity** determines insertion direction
5. **Pre-order DFS** with addFirst() creates the zigzag effect
6. **Choose based on tree shape**: BFS for wide trees, DFS for narrow trees

---

## Interview Tips

**When asked this question:**

1. **Clarify requirements:** Confirm the zigzag pattern alternates each level
2. **Start with BFS:** It's more intuitive for level-order problems
3. **Optimize:** Mention using `LinkedList.addFirst()` instead of reversing
4. **Bonus:** Explain the DFS approach to show deeper understanding
5. **Discuss trade-offs:** BFS vs DFS based on tree characteristics

**Follow-up questions you might face:**
- Can you do it with DFS? (Yes, shown above)
- What if we want spiral order? (Similar approach, different insertion)
- How would you handle a very wide tree? (BFS might use more space)
- How would you handle a very deep tree? (DFS might cause stack overflow)
